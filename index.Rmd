---
title: "Intro to Shiny"
author: "Thomas Wood"
date: "04/02/2022"
theme: readable 
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```


```{r}
slickR::slickR(
    list.files("img",full.names = TRUE,pattern = 'png'),
    height = 700,
    width = '95%')
```

## Create a new shiny app

Open RStudio and go to:

`File > New Project... > New Directory > Shiny Web Application > Enter a directory name and location > Create project` 

R will open a new project for the shiny app, which will contain one file (`app.R`), which will have an example shiny app that you can run by clicking the `Run App` button (top right of the script panel).

This is the home of your app, and any data, pictures, etc. you needs for your app to run need to be stored in the same directory so that they can be accessed by the app once it is deployed.

> Note: Make sure you have shiny installed. 

```{r eval=FALSE, echo=TRUE} 
install.packages("shiny")
```

## Clone the workshop

[You can download a copy of this workshop, and all the code here. ](https://github.com/woodtho/CanDev_2022/archive/refs/heads/main.zip) After downloading the file you can unzip it and then launch the project file (`CanDev_2022.Rproj`) in RStudio.

## App structure

`app.R` has three components:

- a user interface object

- a server function

- a call to the `shinyApp()` function

The user interface (`ui`) object controls the layout and appearance of your app. The `server` function contains the instructions that a computer needs to build the app. Finally the `shinyApp` function creates the Shiny app from an explicit UI/server pair.

### Demo

To run this code, please clone the project using the instructions above. 

- In the code panel on the right side of the screen we can see the code for the server and the UI.
  - In the UI tab, we can see that there is one slider input called "bins" and one plot output called "distPlot"
  - In the server tab, you can see that there is on entry into the output list (`output$distPlot`), which matches the plot output we have in our UI
    - The server code also references out slider input through the input list (`input$bins`)


```{r eval=FALSE, echo=TRUE} 
runApp("Old Faithful Geyser Data", display.mode = "showcase")
```

## Reactivity

Shiny is about making it easy to wire up input values from a web page, making them easily available to you in R, and have the results of your R code be written as output values back out to the web page.

The reactivity frame work used by shiny means that:

- You can change inputs at any time, and the outputs that are impacted will updated immediately to reflect those changes.
- All of this happens automatically, because Shiny is taking care of tracking "dependencies" for you.
- You can simply access the inputs from the browser, using a list-like syntax, and you don't have to worry about write code to monitor changes.

## App template (Default)

> Most of the code in this demo that creates a shiny app can be copied directly into the console and run to lauch a shiny app. Please insure you have the required packages installed.

```{r eval=FALSE, echo=TRUE}
install.packages("shiny")
```

- When building a shiny app, it is best to start with a template. 
- By default RStudio will open all new shiny apps with a simple app that you can then modify it.

Here is the basic skeleton of a shiny app:

```{r eval=FALSE, echo=TRUE}
library(shiny)

# any code that should be executed once, when the app starts. E.g, reading in a
# data file, creating static environment variables.

# Code that creates the UI of the app
ui <- fluidPage(
  # Title for your app
  titlePanel(), 
  
  sidebarLayout(
    
    # Generally inputs are put into the sidebar
    sidebarPanel(
      
      # inputs go here
      
      ),
    
    # And outputs are put into the mainPanel
    mainPanel(
      
      # outputs go here
      
      )
    )
  )

# The server takes inputs from the webpage, updates outputs, and send the
# outputs back to the webpage
server <- function(input, output) { 
  
  # server code goes here
  
  }

# Used to launch the app after defining the UI and server.
shinyApp(ui, server)

```

You do not always have to start an app like this, there are other templates that can be used, but a fluid page, with a sidebar layout is generally a good option. Fluid pages will reflow content when there isn't enough space, and sidebar layouts split your app into two panels, which can be useful for organizing inputs and outputs. 

You can have more control over the layout of an app using functions like `fluidRow()` and `column()`, but for the moment we will just organize the app with into the sidebar and main panel.

## Static UI elements

In addition to reactive elements, you may also want to include some static elements in your UI. Static elements are things like text, or images that do not change with user input. Common tags are available as functions from the shiny package (`div()`, `h1()`, `a()`, `br()`). You can insert less common tags using the `tags` object (e.g., `tags$abbr()`, `tags$figcaption()`). 

Here is an example app with just static content:

```{r eval=FALSE, echo=TRUE}
library(shiny)

# any code that should be executed once, when the app starts. E.g, reading in a
# data file, creating static environment variables.

# Code that creates the UI of the app
ui <- fluidPage(# Title for your app
  titlePanel("A first leavel heading title"),
  
  sidebarLayout(
    # Generally inputs are put into the sidebar
    sidebarPanel(
      h2("A second level heading"),
      "This small Shiny application demonstrates some static UI elements."
    ),
    
    # And outputs are put into the mainPanel
    mainPanel(
      h2("A second level header in the main panel"),
      p('My first paragraph, with some ', strong('bold'), ' text.')
      )
    )
  )

# The server takes inputs from the webpage, updates outputs, and send the
# outputs back to the webpage
server <- function(input, output) { 
  
  # because the app is static, there is no server code!
  
  }

# Used to launch the app after defining the UI and server.
shinyApp(ui, server)

```

- Notice that all of the elements we added were separated with commas inside both the sidebarPanel and the mainPanel 
- [You can look at this tutorial for more examples of adding static content to your interface, incliding adding images and how to align text](http://shiny.rstudio-staging.com/tutorial/written-tutorial/lesson2/) 

## Knowledge check 1

1. Ever app has a UI and a Server
2. Shiny apps are reactive - they have outputs that change based on the values of inputs
3. Use an app template and slot in input, outputs, and server code

## Building your app around **Inputs and outputs**

So far the apps we have seen have been very simple and contained mostly static elements that we created in the UI. But shiny is all about making things interactive. We do that by using inputs and outputs. 

### Inputs

- Created with an `*Input()` function
- Creates the HTML for your apps UI
- Sends values from the web page back to the server

| Function             | Collects                                                                                                 |
|----------------------|----------------------------------------------------------------------------------------------------------|
| `actionButton()`       | A button press                                                                                           |
| `checkboxInput()`      | The state of a check box (TRUE/FALSE)                                                                     |
| `checkboxGroupInput()` | The state of a group of check boxes (a vector of selected values)                                         |
| `dateInput()`          | A single date                                                                                |
| `dateRangeInput()`     | A range of dates (a vector of the min and max date)                                                      |
| `fileInput()`          | A file                                                                                                   |
| `numericInput()`       | A numeric value                                                                                          |
| `passwordInput()`      | A password                                                                                               |
| `radioButtons()`       | The state of a group of radio buttons (Which option is selected)                                         |
| `selectInput()`        | The current selection(s) for a drop down list (vector of length 1, or more, that includes only selected values)|
| `sliderInput()`        | A single number/date/date time or a range of the same (a single value, or a vector of the min and max)   |
| `textInput()`          | A character string  (a vector of the entered text)                                                                   |

#### Syntax

`*Input(inputId, label, ...)`

- inputId needs to be a string and must be unique. You can't use special characters, other than underscores.
  - It is used to create the id in the HTML for your input element
- label describes what the input is for to the user and can use special characters.
- ... means that there are some other specific arguments that are required, depending on the input being used (usually this is something like value or choices).

#### Example

When using a `sidebarLayout()` I typically place most of the inputs into the sidebarPanel and use the mainPanel for my outputs. Notice that the different inputs are separated with commas inside of the sidebarPanel.

```{r eval=FALSE, echo=TRUE}
library(shiny)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(actionButton("actionbutton", "Action Button"),
                 checkboxInput("checkboxInput", "Check box", value = TRUE),
                 checkboxGroupInput("checkboxGroupInput", "Check box group", choices = c("A", "B", "C")),
                 dateInput("dateInput", "Date"),
                 dateRangeInput("dateRangeInput", "Date Range"),
                 fileInput("fileInput", "File"),
                 numericInput("numericInput", "Number", value = 10),
                 passwordInput("passwordInput", "Password"),
                 radioButtons("radioButtons", "Radio Buttons", choices = c("A", "B", "C")),
                 selectInput("selectInput", "Drop down", choices = c("A", "B", "C")),
                 sliderInput("sliderInput", "Silder", min = 1, max = 10, value = 5),
                 textInput("textInput", "Text")
                 ),
    mainPanel(
      
      )
    )
  )

server <- function(input, output) { }

shinyApp(ui, server)

```

### Outputs

- Created with `*Output()` functions.
- Two parts, a space in the UI for the output once it has been rendered by the server, and code in the server to create the output. 
- You must build the object in the server separately.

| Function             | Inserts              |
|----------------------|----------------------|
| `dataTableOutput()`    | An interactive table |
| `tableOutput()`        | A table              |
| `imageOutput()`        | An image             |
| `plotOutput()`         | A plot               |
| `textOutput()`         | Text                 |
| `verbatimTextOutput()` | Text                 |
| `uiOutput()`           | a Shiny UI element   |
| `htmlOutput()`         | Raw HTML             |

#### Syntax

`*Output(outputId, ...)`

- Output typically only require the outputId that is used by the server for saving the rendered HTML content

#### Example

```{r eval=FALSE, echo=TRUE}
library(shiny)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(),
    mainPanel(
      dataTableOutput("dataTableOutput"),
      tableOutput("tableOutput"),
      plotOutput("plotOutput"),
      textOutput("textOutput"),
      verbatimTextOutput("verbatimTextOutput"),
      uiOutput("uiOutput")
      )
    )
  )

server <- function(input, output) { 
  
  output$dataTableOutput <- renderDataTable({ iris })
  
  output$tableOutput <- renderTable({ iris })
  
  output$plotOutput <- renderPlot({ plot(iris) })
  
  output$textOutput <- renderText({ "Some rendered text" })
  
  output$verbatimTextOutput <- renderText({ "Some rendered text" })
  
  output$uiOutput <- renderUI({ selectInput("input", "A rendered UI input", choices = c("A", "B", "C")) })
  
  }

shinyApp(ui, server)

```

- Notice that each output in the UI has a corresponding entry in the server.
- Each output in the server is saved into the `output` object (`output$outputId`)
- There are different rendering function used. These turn the outputs into HTML that can be shown in the UI

## Knowledge check 2

1. 
2. 
3. 

## Tell the server how to assemble inputs into outputs

### Save object to display to output$

After creating a place in the UI for the output, you need to write the code to create the output. The outputs always need to be saved into the `output` object. This looks like:

```{r eval=FALSE, echo=TRUE}

server <- function(input, output) { 
  
  output$outputId <- # code to create the output, e.g., code that can make a plot, or a table
  
}

```

Every output in the UI needs to have a value created in the server

- for example: if you have `plotOutput("plot")` and `tableOutput("table")` in the UI, you need `output$plot` and `output$table` in the server.

### Build objects with render*()

Before an output can be displayed by the webpage, it must be rendered. Which function you use to render an output depends on the type of output. 

| Function          | Creates              |
|-------------------|----------------------|
| `renderDataTable()` | An interactive table |
| `renderTable()`     | A table              |
| `renderPlot()`      | A plot               |
| `renderText()`      | A character string   |
| `renderUI()`        | A Shiny UI element   |

```{r eval=FALSE, echo=TRUE}

server <- function(input, output) { 
  
  output$plot <- renderPlot({
    
    plot(iris)
    
  })
  
  output$table <- renderDataTable({
    
    iris
    
  })
  
  # The same table, but rendered as a static table. 
  
  # output$table <- renderTable({  
  #   iris
  # })
}

```

### Access inputs with input$

```{r eval=FALSE, echo=TRUE}
library(shiny)
library(tidyverse)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("n", "Number", min = 1, max = 100, value = 10),
      selectInput("species", "Species",choices = unique(iris$Species),selected = unique(iris$Species),
                  multiple = TRUE)
    ),
    mainPanel(
      tableOutput("table")
    )
    )
  )

server <- function(input, output) { 
  
  output$table <- renderTable({
    
    iris %>% 
      filter(Species %in% input$species) %>% 
      head(., n = input$n)
    
  })
  
  }

shinyApp(ui, server)

```

## Knowledge check 3

1. 
2. 
3. 


## Deploy your app

You can share a shiny app with anyone who has R and the required packages installed on their computer simply by sharing the code, and another required files, with them.

If you want to share a shiny app with the public, or someone who doesn't have R and the required packages, you need to deploy your app to a shiny server. Shinyapps.io provides a free service that lets you upload a limited number of apps (there are paid plans with more active hours that allow for more apps to be loaded). [You can look at this article for details on deploying apps to Shinyapps.io.](https://shiny.rstudio.com/articles/shinyapps.html)


## R&D Personnel App

To run this code, please clone the project using the instructions above. 

```{r eval=FALSE, echo=TRUE}
runApp()
```

You can look at the source code for the shiny app in `CanDev_2022/app.R`. 

- App header
  - load required packages
  - Read in some data from `CanDev_2022/Data` and do some preprocessing

- UI
  - the app uses the layout template, which divides a fluidPage into a sidebar panel, and a main panel.
  - All of our inputs are located in the sidebar
    - one slider input (`input$year`), one multiple choice select input (`input$category`) and two single choice select inputs (`input$coc`, `input$NAICS`)
  - All of the outputs are located in the main panel
    - one plot output (`"plot"`) and one table output (`"table"`)
  
- Server
  - In the server we create two entries into the output object using the inputs we created in the UI
    - `output$plot`
      - using the `renderPlot({ # Code that returns a plot})` function we can turn code that creates a plot into an output
      - to make the plot interactive, we filter the static data we loaded at the start using the inputs
    - `output$table`
      - using the `renderDataTable({ # Code that returns a table})` function we can turn code that creates a table (or table like object) into an output
      - to make the table interactive, we filter the static data we loaded at the start using the inputs. DataTable outputs by default also have some interactivity within the table (filtering, searching, arranging).
      
